---
execute:
  freeze: auto  # re-render only when source changes
  warning: false
  message: false
editor: source
---

```{r echo=FALSE}
bytes <- file.size("06-shiny.qmd")
words <- bytes/10
minutes <- words/200
```

# Shiny (a web application)

```{r fa-setup, include=FALSE}
library(quarto)
library(fontawesome)
library(ggplot2)
fa_html_dependency()
library(knitr)
library(kableExtra)
library(tidyverse)
# htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```

`r fa("book-open")` Reading: `r ceiling(minutes)` minute(s) at 200 WPM

`r fa("video")` Videos: 0 minute(s)

## Objectives

+ Develop the ability to create responsive user interfaces using fluid, sidebar, main, and conditional panels to enhance user interaction and app functionality.
+ Acquire skills to implement and customize a range of input widgets, including sliders, text fields, and checkboxes, to capture user preferences and inputs effectively.
+ Learn to construct server-side logic that processes user inputs and renders outputs like plots, text, HTML, and tables dynamically.
+ Combine UI elements with server-side scripts to build cohesive and interactive Shiny applications that perform real-time data analysis and visualization.



<br>

::: check-in
## Check-ins {#ch6-checkins .unnumbered}

There are two check-ins for this week:

+ [Check-in 6.1: Shiny with a plot](#checkin6-1)
+ [Check-in 6.2: Shiny with a table](#checkin6-2)

:::

## What is Shiny?

Shiny is an R package that makes it incredibly straightforward to build interactive web applications directly from R. This powerful framework allows data scientists and statisticians to turn their analyses into engaging and user-friendly web apps without requiring extensive knowledge of HTML, CSS, or JavaScript. With Shiny, you can easily create interactive visualizations, data summaries, and complex reports that users can interact with by changing parameters, filtering data, or even uploading their own datasets.

The elegance of Shiny lies in its simplicity and the seamless integration of the analytical power of R with the interactivity of modern web pages. It operates on a server-client model, where the server-side (written in R) handles the computational tasks, and the user interface (UI) is what the end-user interacts with in their web browser. Shiny applications can range from simple data visualizations to comprehensive data dashboards, incorporating real-time analytics that respond to user input, making data exploration both accessible and insightful. Whether for academic research, business intelligence, or creating educational tools, Shiny has become an indispensable tool in the repertoire of anyone looking to bring their data to life.


### User Input (UI)

A User Interface (UI) is the point of human-computer interaction and communication in a device, application, or website. It's the space where interactions between humans and machines occur. The goal of a UI is to make the user's experience as simple and efficient as possible, in terms of accomplishing user goals—what is often called user-centered design.

UI design focuses on anticipating what users might need to do and ensuring that the interface has elements that are easy to access, understand, and use to facilitate those actions. UI brings together concepts from interaction design, visual design, and information architecture. It includes everything from screens, pages, and visual elements like buttons and icons, to design aspects such as typography and color schemes, to the behavior of moving elements, and responsiveness to user input. A well-designed UI not only looks appealing but also creates a seamless, intuitive experience that allows users to complete tasks effectively. In software applications, UI design is typically a combination of graphical (GUI), voice-controlled (VUI), or gesture-based interfaces, depending on the devices and context of use.

#### Elements of traditional Shiny [Image]

**fluidPage:** The `fluidPage` function in Shiny creates a fluid and responsive web page layout that automatically adjusts the sizing of elements to fit the display screen. It's designed to be used as the UI definition for a Shiny app, enabling developers to arrange UI components flexibly across different devices and screen sizes. The fluidPage layout ensures that the content will reflow to optimally use the available space, which is particularly important for providing a consistent user experience on mobile phones, tablets, and desktop computers. This adaptability is key to modern web applications where users may switch between various devices throughout their interaction with the app.

**sidebarLayout:** The `sidebarLayout` is a specialized layout within Shiny that provides a two-panel display: a main panel for main content such as plots or tables, and a sidebar panel for input controls like sliders and buttons. This layout is crucial for creating dashboards and other applications where it is necessary to keep controls accessible while still providing ample space for displaying results. The sidebar typically occupies a fixed portion of the screen, while the main panel adjusts dynamically, ensuring that the user's attention is drawn to the primary content area.

**sidebarPanel:** The `sidebarPanel` function in Shiny generates a column on the side of the app that houses input widgets and controls. It's the go-to solution when you want to present options or actions that the user can take to manipulate the data output displayed in the main panel. By grouping these controls into a sidebar, developers can create an organized and intuitive interface that allows users to easily interact with the app, input data, and adjust parameters without overwhelming the main content display.

**mainPanel:** The `mainPanel` function is an essential part of Shiny's layout system, serving as the container for the primary output of the application. This is where you would place your plots, data tables, and other visual outputs. The mainPanel takes up the bulk of the space in a standard Shiny layout, allowing for a clear and focused presentation of results or information. Its size and layout can be influenced by the elements in the sidebarPanel, making it a dynamic space that can be tailored to fit the needs of various applications and visual content.

Example of all 4 functions within a Shiny:

```{r}
#| eval: false


library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("Old Faithful Geyser Data"),

    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            sliderInput("bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)
```



#### Widgets

Widgets in Shiny are the interactive elements that capture user inputs, allowing them to manipulate and engage with the application in real time. These widgets can range from simple text boxes, sliders, and buttons to more complex date pickers and file upload controls. They are integral to the interactivity of Shiny apps, empowering users to filter data, set parameters for analysis, or even upload their own datasets for visualization. In the Shiny ecosystem, widgets are bound to reactive elements in the server code, meaning that any user interaction can trigger updates to the outputs, creating a dynamic experience. Widgets are designed to be intuitive to use, requiring minimal effort from the user to control the display and behavior of the application. In the following section, we'll dive deeper into the specifics of these widgets, exploring how they can be customized and combined to build sophisticated and user-friendly interfaces.

#### Conditional Panels [GIF]

Conditional panels in Shiny are dynamic UI elements that display content based on specific conditions or user inputs. This functionality is particularly useful when you want to present users with options or information that's only relevant if certain criteria are met, keeping the interface clutter-free and more user-friendly.

For example, you might have a Shiny application where users need to choose between different types of data visualizations. A conditional panel could be used to show additional configuration options that are only relevant for the selected visualization type. Here's a small example:

```{r}
#| eval: false

ui <- fluidPage(
  selectInput("vizType", "Choose a visualization:",
              choices = c("Histogram", "Scatterplot", "Boxplot")),
  conditionalPanel(
    condition = "input.vizType == 'Histogram'",
    sliderInput("bins", "Number of bins:", min = 1, max = 50, value = 30)
  ),
  plotOutput("plot")
)
```

In this code, `selectInput` creates a dropdown menu for choosing a visualization type. The `conditionalPanel` then checks the user's selection through the `condition` argument. If the user selects "Histogram," a slider input for choosing the number of bins appears. The `plotOutput` will display the plot, which reacts to the user's selections. The slider for bin number is only shown when it's relevant, keeping the UI streamlined.




## Widgets

In Shiny, widgets are the building blocks for creating interactive user interfaces. They provide the means for users to input data and adjust parameters within an application. Each widget captures a specific type of input, from simple text and numbers to complex date ranges and file selections. The user's selections are then made available to the server for processing and can trigger updates to the output displayed. Widgets are key to creating a responsive and engaging user experience, allowing for real-time interaction with the underlying data and visualizations.

### Number Inputs (Sliders [one, two], NumericInput)

**Sliders**: Sliders allow users to select a value from a range by moving a slider control. They are ideal for adjusting a parameter within a continuous or discrete range.

Syntax for a single-value slider:

```{r}
#| eval: false
sliderInput(inputId = "id", label = "Sliders Label 1", min = 1, max = 100, value = 50)
```

Syntax for a range slider (selecting two values):
```{r}
#| eval: false
sliderInput(inputId ="id", label = "Sliders Label2",
            min = 1, max = 100, value = c(25, 75))
```

**NumericInput**: This widget lets users input a number by typing into a field, with optional up/down arrows for incrementing the value.

Syntax:
```{r}
#| eval: false
numericInput(inputId ="id", label = "NumericInput Label",
             value = 10, min = 1, max = 100)
```

### Radio Buttons, Dropdowns, Text Input

**Radio Buttons**: Radio buttons present a set of options from which the user can select only one. They are useful for mutually exclusive choices.

```{r}
#| eval: false
radioButtons(inputId ="id", label = "Radio Buttons Label", 
             choices = list("Option 1" = 1, "Option 2" = 2))
```

**Dropdown Menus**: Dropdown menus, also known as select inputs, let users choose an option from a dropdown list.

Syntax:
```{r}
#| eval: false
selectInput(inputId ="id", label = "Dropdown Menus Label",
            choices = c("Option 1", "Option 2"))
```

**Text Input**: Text input fields allow users to enter free-form text.

Syntax:
```{r}
#| eval: false
textInput(inputId ="id", label = "Text Input Label", 
          value = "Enter text here")
```

### Dates, Files, Checkboxes

**Date Input**: Date inputs enable users to select a date from a pop-up calendar, useful for filtering data by date.

Syntax:
```{r}
#| eval: false
dateInput(inputId ="id", label = "Date Input Label",
          value = Sys.Date())
```

**File Input**: File input widgets provide a way for users to upload files into the Shiny application, which can then be processed by the server.

Syntax:
```{r}
#| eval: false
fileInput(inputId ="id", label = "File Input Label")
```

**Checkboxes**: A checkbox allows users to toggle an option on or off, often used for boolean choices.

Syntax:
```{r}
#| eval: false
checkboxInput(inputId ="id", label = "Checkboxes Label", 
              value = TRUE)
```

**Custom Widgets**: Beyond the standard widgets, Shiny also supports custom widgets through the htmlwidgets package. These allow for the integration of custom web components and more sophisticated user inputs. You can explore a variety of htmlwidgets and their uses at [htmlwidgets.org](https://www.htmlwidgets.org/).



## Section 3 - Server

In Shiny applications, the server function houses the logic that processes inputs, performs computations, and determines the output displayed in the user interface. It's where the reactive connections between the UI (User Interface) widgets and the application's results are established. This section focuses on different types of outputs that can be dynamically updated based on user inputs, including plots, text, HTML content, and tables.

### Plot

**Plots** in Shiny are dynamic visualizations that react to user inputs. You can render plots using base R graphics, `ggplot2`, or any other plotting library in R.

Example to render a `ggplot2` plot:
```{r}
#| eval: false
output$plotOutput <- renderPlot({
  ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()
})
```
In the UI, you would use `plotOutput("plotOutput")` to display this plot.

### Text

**Text outputs** allow you to display reactive text in the app, which can include summaries, computations, or any textual content that changes in response to user actions.

Example to render reactive text:
```{r}
#| eval: false
output$textOutput <- renderText({
  paste("The selected number is", input$numberInput)
})
```
Display this in the UI with `textOutput("textOutput")`.

### HTML Text

**HTML Text** outputs enable the incorporation of HTML content within your Shiny app, allowing for more customized and rich text presentations.

Example to render HTML content:
```{r}
#| eval: false
output$htmlOutput <- renderUI({
  HTML("<h1>Hello, Shiny!</h1>")
})
```
This can be displayed using `uiOutput("htmlOutput")` in the UI.

### Table (DT)

The **DT** package, a wrapper around the JavaScript library 'DataTables', provides an interactive table widget. It's useful for displaying data frames or matrices in a searchable, sortable, and paginated table.

To use DT in your Shiny app, you first need to install it:
```{r}
#| eval: false
install.packages("DT")
```

Example to render an interactive table using DT:
```{r}
#| eval: false
library(DT)

output$tableOutput <- renderDT({
  datatable(data, options = list(pageLength = 5))
})
```
In the UI, `DTOutput("tableOutput")` is used to display the table.

These server-side components of Shiny play a crucial role in creating interactive and dynamic web applications. By processing user inputs and rendering outputs like plots, text, HTML content, and interactive tables, Shiny apps can offer a rich and responsive user experience.


## Bringing the UI and Server together

The `shinyApp` function is a critical component of the R Shiny package, acting as the bridge that brings together the user interface (UI) and the server logic to launch an interactive web application. Essentially, it encapsulates the entire Shiny application, defining how the app should be constructed and behave based on the specifications provided in the UI and server definitions. The `shinyApp` function takes two primary arguments: `ui`, which defines the layout and elements that the user interacts with, and `server`, which contains the instructions for how the app responds to user inputs, manipulates data, and generates outputs. This function is what you call to run the app, either locally during development or when deploying the app to a server for broader access.

By leveraging the `shinyApp` function, developers can create sophisticated web applications that enable users to interact with data and visualizations dynamically. For instance, a Shiny app could allow users to filter datasets, adjust parameters for statistical models, or even upload their own data for analysis—all within a web browser, without the need for direct coding by the end-user. This makes `shinyApp` an incredibly powerful tool for data scientists, educators, and businesses to disseminate data-driven insights, facilitate exploratory data analysis, and build interactive tools for a wide range of applications. Whether for educational purposes, research, or commercial products, `shinyApp` serves as the foundation for developing applications that bridge the gap between complex data analyses and user-friendly interfaces.


## All Together

Creating and running an R Shiny app is an exciting way to make your data analyses interactive. Below are step-by-step instructions to create a basic Shiny app that visualizes the Old Faithful Geyser data (`faithful` dataset in R), showcasing components like plots, text outputs, and interactive widgets, similar to the examples we discussed.

### Step 1: Install and Load Shiny Package

First, ensure you have the `shiny` package installed and loaded. If you haven't installed it yet, you can do so by running:

```{r}
#| eval: false
install.packages("shiny")
```

To create a new Shiny Web Application in RStudio, follow these enhanced instructions for a smoother development experience:

1. **Initiate New Project**: Start by locating the green plus button at the top of the RStudio interface, near the other project management icons. This button is designed to create new files, projects, and more within RStudio.

2. **Select Shiny Web Application**: After clicking the green plus button, a dropdown menu will appear with various options for new files and projects. From this menu, select "Shiny Web Application" to begin the setup process for your new app.

3. **Define Application Details**: Upon selection, a dialog window will open asking for specifics about your new Shiny app. Here, you'll need to:
   - **Specify the Directory Name**: Enter a meaningful name for your application. This name will also be used for the folder that contains your app's files.
   - **Choose the Application's Location**: Navigate to where you want your application to reside on your computer. This could be within a specific project directory or a general workspace area, depending on how you organize your files.

4. **Create the Application**: After filling in the directory name and location, click the "Create" button. RStudio will then generate a new folder containing the essential files for a Shiny app. Among these files, you'll find `app.R`, which is the main file where your UI and server logic will reside.

5. **Explore the Template Code**: RStudio provides a basic template within `app.R` to help kickstart your app development. This template includes a simple UI definition with a fluid page layout and a server function that demonstrates how to render a plot based on user input. It's structured to show the separation between UI elements and server-side logic, providing a clear example of how a Shiny app functions.

By following these instructions, you set up a structured environment for developing a Shiny Web Application. The provided template code in `app.R` is an excellent starting point for understanding the anatomy of a Shiny app and serves as a foundation for further customization and development. Explore the template, experiment with adding or modifying UI components and server logic, and begin bringing your data to life in interactive web applications.

### Step 2: Define UI

The user interface (UI) defines how your app will look. For the Old Faithful Geyser data, we'll create a simple UI with a slider to control the number of bins in a histogram:

```{r}
#| eval: false
ui <- fluidPage(

    # Application title
    titlePanel("Old Faithful Geyser Data"),

    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            sliderInput("bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

```

### Step 3: Define Server Logic

The server function contains the instructions to build the plot based on the UI input and display text showing the current number of bins:

```{r}
#| eval: false
server <- function(input, output) {

    output$distPlot <- renderPlot({
        # generate bins based on input$bins from ui.R
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)

        # draw the histogram with the specified number of bins
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}

```

### Step 4: Run the App

Finally, use the `shinyApp` function to run your app:

```{r}
#| eval: false
shinyApp(ui = ui, server = server)
```

This command will start the Shiny app. By default, it will open in your default web browser. You'll see a slider on the left side (sidebar panel) that you can adjust to change the number of bins in the histogram displayed on the right side (main panel). Below the histogram, there's a text output displaying the current number of bins, demonstrating how user inputs can dynamically change the output.

### Noticing Components

In this app:
- **UI Components**: The `fluidPage`, `titlePanel`, `sidebarLayout`, `sidebarPanel`, and `mainPanel` functions define the app's layout. The `sliderInput` widget allows user interaction.
- **Server Logic**: The `renderPlot` and `renderText` functions in the server logic react to changes in the UI, updating the histogram and text based on the slider input.
- **Running the App**: The `shinyApp` function ties the UI and server components together and launches the app.

Creating this sample app provides hands-on experience with the core components of Shiny, illustrating the process of making data interactive and visual. Feel free to modify the app and experiment with adding more widgets or outputs to deepen your understanding of Shiny's capabilities.



## Explore Shiny Examples

To explore the dynamic capabilities of Shiny, let's create three mini examples using the `mtcars` dataset. Each example demonstrates a different aspect of Shiny: rendering plots, displaying text, and showcasing data with DT tables. Try creating these apps yourself to get hands-on experience with Shiny.

### 1. Shiny App for Plotting

This example creates a simple Shiny app that lets the user select a variable from the `mtcars` dataset to visualize its distribution in a histogram.

```{r}
#| eval: false
library(shiny)
library(ggplot2)

ui <- fluidPage(
  selectInput("var", "Choose a variable", choices = names(mtcars)),
  plotOutput("histPlot")
)

server <- function(input, output) {
  output$histPlot <- renderPlot({
    ggplot(mtcars, aes_string(x = input$var)) + 
      geom_histogram(binwidth = 1) + 
      theme_minimal()
  })
}

shinyApp(ui = ui, server = server)
```

### 2. Shiny App for Displaying Text

This example shows how to display the mean of a selected variable from the `mtcars` dataset.

```{r}
#| eval: false
library(shiny)

ui <- fluidPage(
  selectInput("var", "Choose a variable", choices = names(mtcars)),
  textOutput("meanText")
)

server <- function(input, output) {
  output$meanText <- renderText({
    meanVar <- mean(mtcars[[input$var]], na.rm = TRUE)
    paste("The mean of", input$var, "is:", meanVar)
  })
}

shinyApp(ui = ui, server = server)
```

### 3. Shiny App with DT Table

This example demonstrates how to display the `mtcars` dataset in an interactive table using the `DT` package.

```{r}
#| eval: false
library(shiny)
library(DT)

ui <- fluidPage(
  DTOutput("dataTable")
)

server <- function(input, output) {
  output$dataTable <- renderDT({
    datatable(mtcars, options = list(pageLength = 5))
  })
}

shinyApp(ui = ui, server = server)
```

Each of these examples highlights a different feature of Shiny, from visualizing data with plots, summarizing data with dynamic text, to displaying datasets with interactive tables. To get the most out of these examples, create a new Shiny app for each and experiment by running them on your machine. This hands-on practice will deepen your understanding of how Shiny works and how you can leverage it to build your own interactive web applications.


::: check-in
## Check-in 6.1: Understanding the UI {#checkin6-1 .unnumbered}
**1. **

```{r}
#| eval: false


ui <- _______(

    # Application title
    titlePanel("Old Faithful Geyser Data"),

    # Sidebar with a slider input for number of bins 
    _______(
        _______(
            _______"bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),

        # Show a plot of the generated distribution
        _______(
           plotOutput("distPlot")
        )
    )
)
```


**2. What function is used to create a display that automatically adjusts to the dimensions of your user’s browser window? **


- fixedPage()
- fluidPage()
- sliderInput()
- mainPanel()
- renderUI()

**3. What function is used to create a widget that allows the user to select a range of values using a slider bar?**


- sliderInput()
- rangeInput()
- dateRangeInput()
- numericInput()
- selectInput()


:::


::: check-in
## Check-in 6.2: Working with the Server {#checkin6-2 .unnumbered}
**1. **
```{r}
#| eval: false

# Define server logic required to draw a histogram
server <- function(______, ______) {

    output$distPlot <- ______({
        # generate bins based on input$bins from ui.R
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)

        # draw the histogram with the specified number of bins
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}

# Run the application 
______(ui = ui, server = server)
```


**2. What is the purpose of the server function in a Shiny app?**

- To provide the server-side logic and output generation
- To define the user interface elements and layout
- To create a Shiny app object from the UI and server components
- To run the Shiny app on a web server


**3. What are the two parameters that the server function must take?**

- ui and server
- input and output
- app and shiny
- data and plot

**4. What is the difference between output and render functions in the server function?**

- Output functions are used to define the output types, while render functions are used to generate the output values
- Output functions are used to create the results, while render functions are used to display the results
- Output functions are used to display the results, while render functions are used to create the results
- Output functions are used to generate the output values, while render functions are used to define the output types

:::


PA 6: Coming Soon

Lab 6: Coming Soon
